{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! Hello! Welcome to BWSI'19 official Racecar Website! Racecar Dashboard Name Link BWSI Dashboard Click Here Racecar Slack Click Here RacecarWiki Click Here","title":"Home"},{"location":"#welcome","text":"Hello! Welcome to BWSI'19 official Racecar Website!","title":"Welcome!"},{"location":"#racecar-dashboard","text":"Name Link BWSI Dashboard Click Here Racecar Slack Click Here RacecarWiki Click Here","title":"Racecar Dashboard"},{"location":"cheatsheets/opencv/","text":"OpenCV in Python Cheatsheet What to import import cv2 - Imports OpenCV module import numpy as np - Imports Numpy module from cv_bridge import CvBridge, CvBridgeException - Imports cv_bridge to allow changing between ROS messages and images that can be altered with OpenCV. ROS and OpenCV CvBridge() - Instantiates a new bridge object. bridge.imgmsg_to_cv2(image_msg, \"bgr8\") - Converts the image message into an OpenCV image. bridge.cv2_to_imgmsg(image_cv) - Converts the OpenCV image into an image message. cv2.imread('example.jpg') - Reads an image that can be edited using OpenCV. The parameter is the image file. cv2.imshow('image', img) - Displays an image in a window. First parameter is the window name, second is the image. cv2.imwrite('image.png',img) - Saves an image. First parameter is the file name, second is the image to be saved. cv2.waitKey(0) - Waits indefinitely for a key stroke. Needed to process many other GUI events, so is necessary to display the image. cv2.destroyAllWindows() - Destroys all windows created by OpenCV. Other OpenCV functions cv2.line(img ,(0,0), (100,100), (255,0,0), 5) - Draws a line on img, that begins at (0,0) and ends at (100,100), with color (255,0,0) (blue, since it's BGR), and thickness of 5 px. cv2.rectangle(img, (0,100), (150,0), (0,255,0),2) - Draws a rectangle on img with the top left corner at (0,100) and bottom right corner at (150,0), with color (0,255,0) (green) and thickness of 2px. cv2.resize(img, (int (img.shape[1]/4)), (int (img.shape[0]/4))) - Resizes img to be a 1/4th its width (img.shape[1]) and 1/4th its height (img.shape[0]). cv2.putText(img, 'hello', (150,150), textFont, 5, (255,255,255), 2, cv2.LINE_AA) - Puts the text \"hello\" on img at (150,150) (bottom-left corner), in font textFont with scale 5, in color (255,255,255) (white), with thickness of 2 px and lineType of cv2.LINE_AA. cv2.cvtColor(img, cv2.COLOR_BGR2HSV) - Converts img from the BGR color space to HSV. cv2.inRange(hsvImage, lower, upper) - Thresholds the HSV image to get only the colors that fall within the lower and upper bounds, where lower and upper are numpy arrays that specify HSV values. cv2.bitwise_and(img, img, mask=imgMask) - Masks the original image with imgMask being the result of cv2.inRange(). cv2.findContours(img,cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) - Finds contours. First parameter is the source image, second is contour retrieval mode, and third is contour approximation method. Returns the modfied image, the contours, and hierarchy. cv2.drawContours(img, [cont], 0, (0,255,0),3) - Draw contours on img in the color (0,255,0) (green) with thickness of 3px. [cont] is a list of the contours, and 0 is the index of contours (for drawing individual ones). To draw all contours, pass -1 as the third argument. Sources OpenCV Documentation","title":"OpenCV"},{"location":"cheatsheets/opencv/#opencv-in-python-cheatsheet","text":"","title":"OpenCV in Python Cheatsheet"},{"location":"cheatsheets/opencv/#what-to-import","text":"import cv2 - Imports OpenCV module import numpy as np - Imports Numpy module from cv_bridge import CvBridge, CvBridgeException - Imports cv_bridge to allow changing between ROS messages and images that can be altered with OpenCV.","title":"What to import"},{"location":"cheatsheets/opencv/#ros-and-opencv","text":"CvBridge() - Instantiates a new bridge object. bridge.imgmsg_to_cv2(image_msg, \"bgr8\") - Converts the image message into an OpenCV image. bridge.cv2_to_imgmsg(image_cv) - Converts the OpenCV image into an image message. cv2.imread('example.jpg') - Reads an image that can be edited using OpenCV. The parameter is the image file. cv2.imshow('image', img) - Displays an image in a window. First parameter is the window name, second is the image. cv2.imwrite('image.png',img) - Saves an image. First parameter is the file name, second is the image to be saved. cv2.waitKey(0) - Waits indefinitely for a key stroke. Needed to process many other GUI events, so is necessary to display the image. cv2.destroyAllWindows() - Destroys all windows created by OpenCV.","title":"ROS and OpenCV"},{"location":"cheatsheets/opencv/#other-opencv-functions","text":"cv2.line(img ,(0,0), (100,100), (255,0,0), 5) - Draws a line on img, that begins at (0,0) and ends at (100,100), with color (255,0,0) (blue, since it's BGR), and thickness of 5 px. cv2.rectangle(img, (0,100), (150,0), (0,255,0),2) - Draws a rectangle on img with the top left corner at (0,100) and bottom right corner at (150,0), with color (0,255,0) (green) and thickness of 2px. cv2.resize(img, (int (img.shape[1]/4)), (int (img.shape[0]/4))) - Resizes img to be a 1/4th its width (img.shape[1]) and 1/4th its height (img.shape[0]). cv2.putText(img, 'hello', (150,150), textFont, 5, (255,255,255), 2, cv2.LINE_AA) - Puts the text \"hello\" on img at (150,150) (bottom-left corner), in font textFont with scale 5, in color (255,255,255) (white), with thickness of 2 px and lineType of cv2.LINE_AA. cv2.cvtColor(img, cv2.COLOR_BGR2HSV) - Converts img from the BGR color space to HSV. cv2.inRange(hsvImage, lower, upper) - Thresholds the HSV image to get only the colors that fall within the lower and upper bounds, where lower and upper are numpy arrays that specify HSV values. cv2.bitwise_and(img, img, mask=imgMask) - Masks the original image with imgMask being the result of cv2.inRange(). cv2.findContours(img,cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) - Finds contours. First parameter is the source image, second is contour retrieval mode, and third is contour approximation method. Returns the modfied image, the contours, and hierarchy. cv2.drawContours(img, [cont], 0, (0,255,0),3) - Draw contours on img in the color (0,255,0) (green) with thickness of 3px. [cont] is a list of the contours, and 0 is the index of contours (for drawing individual ones). To draw all contours, pass -1 as the third argument.","title":"Other OpenCV functions"},{"location":"cheatsheets/opencv/#sources","text":"OpenCV Documentation","title":"Sources"},{"location":"cheatsheets/python/","text":"ROS in Python cheatsheet What to import import rospy - To get all of the essential ROS classes from [message folder].msg import [name of message type] - To import a message type (use * to get all of them from the folder) from cv_bridge import CvBridge, CvBridgeException - To get the bridge to translate from image msg to OpenCV image rospy classes and functions to use rospy.init_node(node_name) - Initializes the node onto the ROS Graph rospy.Subscriber - A subscriber will allow receiving messages from a topic onto a callback function Init: sub = rospy.Subscriber(topic_name, message_type, callback_function_name, queue_size = _) - Initializes with a topic and message type onto a callback function which is called whenever it is published onto Callback Function: def callback_function_name([self if class], message_type): - The callback function is given the data from the message rospy.Publisher - Publishers allow us to publish messages onto a topic Init: pub = rospy.Publisher(topic_name, message_type, queue_size = _) - Initialize it as an object with a topic and a message type (can already be existing) Publish: pub.publish([variable of message_type type]) - Publishes the data rospy.is_shutdown() - While the current roscore is still running rospy.spin() - Gives the functionality to ROS until roscore is shut down Python Conventions if __name__ == \"__main__\": - Acts as a main function, only runs if python [script_name] is used on it Naming variable_name (underscores) ClassName (CamelCase) 4 spaces per tab Put all functionality in a class (?)","title":"Python"},{"location":"cheatsheets/python/#ros-in-python-cheatsheet","text":"","title":"ROS in Python cheatsheet"},{"location":"cheatsheets/python/#what-to-import","text":"import rospy - To get all of the essential ROS classes from [message folder].msg import [name of message type] - To import a message type (use * to get all of them from the folder) from cv_bridge import CvBridge, CvBridgeException - To get the bridge to translate from image msg to OpenCV image","title":"What to import"},{"location":"cheatsheets/python/#rospy-classes-and-functions-to-use","text":"rospy.init_node(node_name) - Initializes the node onto the ROS Graph rospy.Subscriber - A subscriber will allow receiving messages from a topic onto a callback function Init: sub = rospy.Subscriber(topic_name, message_type, callback_function_name, queue_size = _) - Initializes with a topic and message type onto a callback function which is called whenever it is published onto Callback Function: def callback_function_name([self if class], message_type): - The callback function is given the data from the message rospy.Publisher - Publishers allow us to publish messages onto a topic Init: pub = rospy.Publisher(topic_name, message_type, queue_size = _) - Initialize it as an object with a topic and a message type (can already be existing) Publish: pub.publish([variable of message_type type]) - Publishes the data rospy.is_shutdown() - While the current roscore is still running rospy.spin() - Gives the functionality to ROS until roscore is shut down","title":"rospy classes and functions to use"},{"location":"cheatsheets/python/#python-conventions","text":"if __name__ == \"__main__\": - Acts as a main function, only runs if python [script_name] is used on it Naming variable_name (underscores) ClassName (CamelCase) 4 spaces per tab Put all functionality in a class (?)","title":"Python Conventions"},{"location":"cheatsheets/racecar/","text":"Car Cheatsheet Setting up the car Set the car on a block of some sort, such that the wheels aren't touching the table/ground Unplug the battery charger, and connect the battery into the car (one some cars, there will be two identical wire; you only need to plug in one. On these battery, quickly press the battery's power button. If you hold it, it will change the settings. On others, there is a wire marked blue and one marked green, which you must plug into the corresponding ports). Turn on the car using the power button on the TX2 Plug in the motor battery Your car should look like this: SSHing Make sure you're connected to the car's wifi On your computer, use this command: ssh racecar@192.168.1.car_number . The password is racecar@mit If you get an error, ask one of the TAs for help Using the Controller You must hold down LB to use the controller to drive If the Mode light is turned on, press Mode until it turns off The controller must be in the D mode (this is changed by a switch in between the bumpers). The left joystick controls speed, and the right joystick turns Driving self.cmd.drive.speed : changes the car's velocity self.cmd.drive.steering_angle : changes the angle of the wheels","title":"Racecar"},{"location":"cheatsheets/racecar/#car-cheatsheet","text":"","title":"Car Cheatsheet"},{"location":"cheatsheets/racecar/#setting-up-the-car","text":"Set the car on a block of some sort, such that the wheels aren't touching the table/ground Unplug the battery charger, and connect the battery into the car (one some cars, there will be two identical wire; you only need to plug in one. On these battery, quickly press the battery's power button. If you hold it, it will change the settings. On others, there is a wire marked blue and one marked green, which you must plug into the corresponding ports). Turn on the car using the power button on the TX2 Plug in the motor battery Your car should look like this:","title":"Setting up the car"},{"location":"cheatsheets/racecar/#sshing","text":"Make sure you're connected to the car's wifi On your computer, use this command: ssh racecar@192.168.1.car_number . The password is racecar@mit If you get an error, ask one of the TAs for help","title":"SSHing"},{"location":"cheatsheets/racecar/#using-the-controller","text":"You must hold down LB to use the controller to drive If the Mode light is turned on, press Mode until it turns off The controller must be in the D mode (this is changed by a switch in between the bumpers). The left joystick controls speed, and the right joystick turns","title":"Using the Controller"},{"location":"cheatsheets/racecar/#driving","text":"self.cmd.drive.speed : changes the car's velocity self.cmd.drive.steering_angle : changes the angle of the wheels","title":"Driving"},{"location":"cheatsheets/ros/","text":"ROS Command Line cheatsheet Launching ROS roscore - Allows all ROS nodes to communicate with each other, so necessary for all ROS usage rosrun [package] [executable] - Launches a ROS node, executable can be a .py file or a C/C++ executable roslaunch [package] [launch_script] - Uses a .launch file to run multiple other ROS nodes and roscore Debugging Information rosnode [command] - Displays debugging information about ROS nodes rosnode list - Lists the active nodes rosnode ping [node_name] - Tests connectivity to node rosnode info [node_name] - Prints information about specific node rosnode machine [machine_name] - Lists nodes running on a machine rosnode kill [node_name] - Kills a running node -a kills all nodes rostopic [command] - Displays debugging information about ROS topics rostopic list - Lists the active topics rostopic bw [topic_name] - Prints the bandwidth used by topic rostopic hz [topic_name] - Prints the publishing rate of the topic rostopic echo [topic_name] - Print topic messages to the screen rostopic type [topic_name] - Print topic's message type rostopic pub [topic_name] [message type] (message) - Publish data to the topic rostopic find [message_type] - Find topics by message type rosmsg [command] - Displays information about ROS message data structures rosmsg show [message_name] - Print the fields in the message rosmsg users [message_name] - Search for code using the message rosmsg package [package_name] - List all the messages in a package rosmsg packages [message_name] - List all the packages with specific message rosmsg md5 [message_name] - Print the message md5 sum Recording rosbag [command] - Used for storing ROS graph data rosbag record [topics_names] - Records the ROS data into a .bag file (-a records all topics) rosbag play [.bag file] - Plays back the ROS data that was recorded Visualization Tools Note: These tools work best with the monitor directly plugged into the car. If you have no monitor, you can ssh into the car using the command ssh racecar@racecar -Y , which will allow windows on the racecar to appear on your computer. These will be super laggy though. * rqt_graph - Displays interactive graph of ROS nodes/topics * rqt_image_view - Displays any topic messages whose type is sensor_msgs/Image * rqt_bag - Graphical tool for watching .bag files * rqt_deps - Generates PDF of ROS dependencies * rqt_plot - Plots numerical data on ROS topic over time * rqt_logger * rviz - 3D visualization of robot with sensor data plotted around it * gazebo - A simulation system where the ROS robot can operate just like it normally would","title":"ROS"},{"location":"cheatsheets/ros/#ros-command-line-cheatsheet","text":"","title":"ROS Command Line cheatsheet"},{"location":"cheatsheets/ros/#launching-ros","text":"roscore - Allows all ROS nodes to communicate with each other, so necessary for all ROS usage rosrun [package] [executable] - Launches a ROS node, executable can be a .py file or a C/C++ executable roslaunch [package] [launch_script] - Uses a .launch file to run multiple other ROS nodes and roscore","title":"Launching ROS"},{"location":"cheatsheets/ros/#debugging-information","text":"rosnode [command] - Displays debugging information about ROS nodes rosnode list - Lists the active nodes rosnode ping [node_name] - Tests connectivity to node rosnode info [node_name] - Prints information about specific node rosnode machine [machine_name] - Lists nodes running on a machine rosnode kill [node_name] - Kills a running node -a kills all nodes rostopic [command] - Displays debugging information about ROS topics rostopic list - Lists the active topics rostopic bw [topic_name] - Prints the bandwidth used by topic rostopic hz [topic_name] - Prints the publishing rate of the topic rostopic echo [topic_name] - Print topic messages to the screen rostopic type [topic_name] - Print topic's message type rostopic pub [topic_name] [message type] (message) - Publish data to the topic rostopic find [message_type] - Find topics by message type rosmsg [command] - Displays information about ROS message data structures rosmsg show [message_name] - Print the fields in the message rosmsg users [message_name] - Search for code using the message rosmsg package [package_name] - List all the messages in a package rosmsg packages [message_name] - List all the packages with specific message rosmsg md5 [message_name] - Print the message md5 sum","title":"Debugging Information"},{"location":"cheatsheets/ros/#recording","text":"rosbag [command] - Used for storing ROS graph data rosbag record [topics_names] - Records the ROS data into a .bag file (-a records all topics) rosbag play [.bag file] - Plays back the ROS data that was recorded","title":"Recording"},{"location":"cheatsheets/ros/#visualization-tools","text":"Note: These tools work best with the monitor directly plugged into the car. If you have no monitor, you can ssh into the car using the command ssh racecar@racecar -Y , which will allow windows on the racecar to appear on your computer. These will be super laggy though. * rqt_graph - Displays interactive graph of ROS nodes/topics * rqt_image_view - Displays any topic messages whose type is sensor_msgs/Image * rqt_bag - Graphical tool for watching .bag files * rqt_deps - Generates PDF of ROS dependencies * rqt_plot - Plots numerical data on ROS topic over time * rqt_logger * rviz - 3D visualization of robot with sensor data plotted around it * gazebo - A simulation system where the ROS robot can operate just like it normally would","title":"Visualization Tools"},{"location":"racecar-parts/lidar/","text":"LIDAR Sensor Hardware A LIDAR sensor is a distance sensor that spins around. Our particular sensor is the Hokuyo UST-10LX scanning laser rangefinder. Specs Wiring Sends data over ethernet Requires external power Data Detection range: 0.06 m to about 10 m Detection accuracy: +- 40 mm Scan angle range: 270\u00b0 Scan angle resolution: 1081 steps (\u2248 0.25\u00b0 increment between distance measurements) Scan speed: 25 ms (40 Hz) This sensor has an MSRP of 1.6 US kilodollars . Be aware of this as you conduct your testing. Usage in ROS We've already programmed the car to make a node that gets the LIDAR data and publishes it via messages to the /scan topic. Each message is of the type LaserScan . The actual scan data lies in the message's ranges attribute , which contains a list of all the distances (in meters) the LIDAR measured during one scan. Other LaserScan message attributes Some notable ones include angle_increment , angle_max , angle_min , range_max , range_min , scan_time , and intensities . For a full list, see: ros.org See the diagram to figure out the angles at which the distances are measured: How to visualize the data onscreen. In the car\u2019s terminal (ssh in if necessary), run `teleop`. In the computer\u2019s terminal (or car\u2019s if you have a monitor plugged in), run `rviz`. In rviz, select \"base_link\" from the \"frame\" dropdown menu. In rviz, press \"add\". In the popup, go to the \"By topic\" tab and select \"LaserScan\" from the \"\\scan\" topic. Hit the \"ok\" and enjoy! Important code snippets: #imports the dataype/class LaserScan from sensor_msgs.msg import LaserScan #a /scan topic subscriber laser_sub = rospy.Subscriber(\"/scan\", LaserScan, self.laser_callback, queue_size=1) #a callback function for the subscriber def laser_callback(scan_data): print(scan_data.ranges) If you're working inside another class, try using self.laser_sub = ... and def laser_callback(self, scan_data): ... instead.","title":"Lidar"},{"location":"racecar-parts/lidar/#lidar-sensor","text":"","title":"LIDAR Sensor"},{"location":"racecar-parts/lidar/#hardware","text":"A LIDAR sensor is a distance sensor that spins around. Our particular sensor is the Hokuyo UST-10LX scanning laser rangefinder. Specs Wiring Sends data over ethernet Requires external power Data Detection range: 0.06 m to about 10 m Detection accuracy: +- 40 mm Scan angle range: 270\u00b0 Scan angle resolution: 1081 steps (\u2248 0.25\u00b0 increment between distance measurements) Scan speed: 25 ms (40 Hz) This sensor has an MSRP of 1.6 US kilodollars . Be aware of this as you conduct your testing.","title":"Hardware"},{"location":"racecar-parts/lidar/#usage-in-ros","text":"We've already programmed the car to make a node that gets the LIDAR data and publishes it via messages to the /scan topic. Each message is of the type LaserScan . The actual scan data lies in the message's ranges attribute , which contains a list of all the distances (in meters) the LIDAR measured during one scan. Other LaserScan message attributes Some notable ones include angle_increment , angle_max , angle_min , range_max , range_min , scan_time , and intensities . For a full list, see: ros.org See the diagram to figure out the angles at which the distances are measured: How to visualize the data onscreen. In the car\u2019s terminal (ssh in if necessary), run `teleop`. In the computer\u2019s terminal (or car\u2019s if you have a monitor plugged in), run `rviz`. In rviz, select \"base_link\" from the \"frame\" dropdown menu. In rviz, press \"add\". In the popup, go to the \"By topic\" tab and select \"LaserScan\" from the \"\\scan\" topic. Hit the \"ok\" and enjoy!","title":"Usage in ROS"},{"location":"racecar-parts/lidar/#important-code-snippets","text":"#imports the dataype/class LaserScan from sensor_msgs.msg import LaserScan #a /scan topic subscriber laser_sub = rospy.Subscriber(\"/scan\", LaserScan, self.laser_callback, queue_size=1) #a callback function for the subscriber def laser_callback(scan_data): print(scan_data.ranges) If you're working inside another class, try using self.laser_sub = ... and def laser_callback(self, scan_data): ... instead.","title":"Important code snippets:"},{"location":"racecar-parts/zed/","text":"Camera Sensor Hardware Each car has a ZED stereo camera . It can output a standard video stream, or it can output a depth estimate stream. Specs Wiring: Sends data and receives power via USB Data: Frames per second & resolution: 60fps @ 720p Field of view: 110\u00b0 Depth range: 0.5 - 20 m Can calculate odometry based on visual data This sensor has an MSRP of 0.5 US kilodollars . Be aware of this as you conduct your testing. Usage in ROS To use the ZED's data in ROS, first run `startZED` on the car's terminal . Beyond that, you usually will not have to interact with ZED data directly. Rather, we will often give you programs that process the ZED\u2019s data. For instance, in ZED.py , the \u201cimage_converter\u201d class takes in the raw data and converts it to CV2 format, which helps us greatly to process the image. For the curious though, we can get ZED data like we get other sensor data The ZED nodes publish different data to different topics. There are left/right camera topics and a depth topic. We often use `/zed/rgb/image_rect_color` . Each message is of the type `Image`. For a full list of `Image` message attributes, see ros.org . How to visualize the data onscreen. If you're ssh-ed into the car: on the car's terminal (i.e. ssh-in), run `startZED` on the computer's terminal, run `rqt_image_view` select the topic you would like to view If you have a monitor directly plugged in: Run `startZEDviz` in the terminal for a totally awesome visualization in RVIZ. Be sure to click on \"DepthCloud\" for the full effect.","title":"ZED"},{"location":"racecar-parts/zed/#camera-sensor","text":"","title":"Camera Sensor"},{"location":"racecar-parts/zed/#hardware","text":"Each car has a ZED stereo camera . It can output a standard video stream, or it can output a depth estimate stream. Specs Wiring: Sends data and receives power via USB Data: Frames per second & resolution: 60fps @ 720p Field of view: 110\u00b0 Depth range: 0.5 - 20 m Can calculate odometry based on visual data This sensor has an MSRP of 0.5 US kilodollars . Be aware of this as you conduct your testing.","title":"Hardware"},{"location":"racecar-parts/zed/#usage-in-ros","text":"To use the ZED's data in ROS, first run `startZED` on the car's terminal . Beyond that, you usually will not have to interact with ZED data directly. Rather, we will often give you programs that process the ZED\u2019s data. For instance, in ZED.py , the \u201cimage_converter\u201d class takes in the raw data and converts it to CV2 format, which helps us greatly to process the image. For the curious though, we can get ZED data like we get other sensor data The ZED nodes publish different data to different topics. There are left/right camera topics and a depth topic. We often use `/zed/rgb/image_rect_color` . Each message is of the type `Image`. For a full list of `Image` message attributes, see ros.org . How to visualize the data onscreen. If you're ssh-ed into the car: on the car's terminal (i.e. ssh-in), run `startZED` on the computer's terminal, run `rqt_image_view` select the topic you would like to view If you have a monitor directly plugged in: Run `startZEDviz` in the terminal for a totally awesome visualization in RVIZ. Be sure to click on \"DepthCloud\" for the full effect.","title":"Usage in ROS"},{"location":"week1/01_monday/lab/","text":"It's time to use the actual racecar! In this lab you will be taking the wall following code that you ran in simulation and running it on the car. You will also be building a safety controller to prevent your racecar from crashing into obstacles. Part 1: Review Hardware The racecar platform is exciting and fast but it is not a toy. The hardware we have on board is extremely expensive and it is your responsibility to keep it in good condition for future classes. The racecar can survive a couple light bumps but if it goes flying into a wall it can be destroyed. The whole frame can split in half, the lidar can get scratched, the TX2 can get damaged, etc. Any one of these repairs can cost hundreds if not thousands of dollars in addition to the dozens of hours repair time. If your car develops hardware issues for any reason, please tell an instrutor immediately and we will do our best to repair it. Over the course of a full semester, most teams will probably have some sort of hardware issue and it is typically not a big deal. That being said, do not exhibit obviously reckless behavior! Before continuing, please review a full breakdown of the hardware here . Part 2: Wall Following Use scp or git clone to get one of your team members' wall following code from the simulated lab onto the car. Just like in the simulated lab the wall follower should live in the src folder of your workspace, ~/racecar_ws/src/[WALL_FOLLOWER_CODE] . catkin_make in the root of your workspace to rebuild it and then source ~/racecar_ws/devel/setup.bash . Before running the wall_follower change the drive_topic param to /vesc/ackermann_cmd_mux/input/navigation . See the muxes section below for more details. Get the car into a safe location and make sure teleop is running. In another terminal launch roslaunch wall_follower wall_follower.launch Hopefully this will work without any changes! To activate the wall follower, hold down the right bumper on the joystick If necessary, tune the parameters in the wall follower so that it works well in real life. Combine ideas from multiple team members' implementations of the wall follower to make a more robust controller. Consider how to quantify how well a controller performs, and techniques to improve controller performance. Some reasons it may not be working The number of lidar beams is different than in the simulator The field of view is different than in the simulator. If you have a velodyne car, the lidar is not pointed forwards, it is rotated by 60 degrees. Part 3: Safety Controller Now that you\u2019ve got your wall follower working we want you to build a safety controller. In future labs the racecar will be moving at high speeds so we need you to build a system that protects it from crashes. Create a new package for your safety controller (place it in ~/racecar_ws/src ). Your goal is to make a node in this pacakge that prevents the racecar from crashing into obstacles. We want you to be able to demonstrate that your safety controller is robust. You should be able to attempt to crash the racecar in a variety of scenarios and have the safety controller prevent the crashes. You should also be able to walk in front of the racecar without it running into you. At the same time your racecar should not be \"scared\". You should still be able to drive close to walls, turn around corners, go fast etc. without the racecar freezing in its tracks. You will be required to run your safety controller in all future labs so don't cripple yourself with something overprotective. Please be careful when you are testing . Always have your joystick ready to stop the racecar and start very slow. Muxes The racecar has a command mux with different levels of priority that you will need in building your safety controller. The navigation topic you have been publishing to is an alias for the highest priority navigation topic in the mux ( defined here ): /vesc/ackermann_cmd_mux/input/navigation -> /vesc/high_level/ackermann_cmd_mux/input/nav_0 For brevity we will refer to /vesc/high_level/ackermann_cmd_mux/input/nav_i as .../nav_i in this handout ( this doesn't work on the actual racecar ). Driving commands sent to .../nav_0 override driving commands sent to .../nav_1 , .../nav_2 , etc. Likewise driving commands sent to .../nav_1 override driving commands sent to .../nav_2 , .../nav_3 , etc. You can use this structure to layer levels of control. For example, a robot whose job it is to explore randomly and collect minerals as it finds them could use 2 muxes. The controller that explores randomly could publish to a lower priority topic like .../nav_1 . Whenever the vision system detects minerals, it could begin to publish commands to a higher priority topic like .../nav_0 . .../nav_0 would override .../nav_1 until the minerals have been depleted and commands stopped being published to .../nav_0 . The navigation command with the highest priority is then published to /vesc/high_level/ackermann_cmd_mux/output . This topic is then piped to /vesc/low_level/ackermann_cmd_mux/input/navigation and fed into another mux with the following priorities (from highest to lowest): /vesc/low_level/ackermann_cmd_mux/input/teleop /vesc/low_level/ackermann_cmd_mux/input/safety /vesc/low_level/ackermann_cmd_mux/input/navigation .../teleop is the topic that the joystick publishes to. This will always have the highest priority. .../safety has the next highest priority. It will override anything published to .../navigation . This is where your safety controller will publish. So for your safety controller this means: Subscribe to /vesc/high_level/ackermann_cmd_mux/output to intercept the driving command that is being published. Subscribe to sensors like /scan . Publish to /vesc/low_level/ackermann_cmd_mux/input/safety if the command being published to the navigation topic is in danger of crashing the racecar.","title":"Monday"},{"location":"week1/01_monday/lab/#part-1-review-hardware","text":"The racecar platform is exciting and fast but it is not a toy. The hardware we have on board is extremely expensive and it is your responsibility to keep it in good condition for future classes. The racecar can survive a couple light bumps but if it goes flying into a wall it can be destroyed. The whole frame can split in half, the lidar can get scratched, the TX2 can get damaged, etc. Any one of these repairs can cost hundreds if not thousands of dollars in addition to the dozens of hours repair time. If your car develops hardware issues for any reason, please tell an instrutor immediately and we will do our best to repair it. Over the course of a full semester, most teams will probably have some sort of hardware issue and it is typically not a big deal. That being said, do not exhibit obviously reckless behavior! Before continuing, please review a full breakdown of the hardware here .","title":"Part 1: Review Hardware"},{"location":"week1/01_monday/lab/#part-2-wall-following","text":"Use scp or git clone to get one of your team members' wall following code from the simulated lab onto the car. Just like in the simulated lab the wall follower should live in the src folder of your workspace, ~/racecar_ws/src/[WALL_FOLLOWER_CODE] . catkin_make in the root of your workspace to rebuild it and then source ~/racecar_ws/devel/setup.bash . Before running the wall_follower change the drive_topic param to /vesc/ackermann_cmd_mux/input/navigation . See the muxes section below for more details. Get the car into a safe location and make sure teleop is running. In another terminal launch roslaunch wall_follower wall_follower.launch Hopefully this will work without any changes! To activate the wall follower, hold down the right bumper on the joystick If necessary, tune the parameters in the wall follower so that it works well in real life. Combine ideas from multiple team members' implementations of the wall follower to make a more robust controller. Consider how to quantify how well a controller performs, and techniques to improve controller performance.","title":"Part 2: Wall Following"},{"location":"week1/01_monday/lab/#some-reasons-it-may-not-be-working","text":"The number of lidar beams is different than in the simulator The field of view is different than in the simulator. If you have a velodyne car, the lidar is not pointed forwards, it is rotated by 60 degrees.","title":"Some reasons it may not be working"},{"location":"week1/01_monday/lab/#part-3-safety-controller","text":"Now that you\u2019ve got your wall follower working we want you to build a safety controller. In future labs the racecar will be moving at high speeds so we need you to build a system that protects it from crashes. Create a new package for your safety controller (place it in ~/racecar_ws/src ). Your goal is to make a node in this pacakge that prevents the racecar from crashing into obstacles. We want you to be able to demonstrate that your safety controller is robust. You should be able to attempt to crash the racecar in a variety of scenarios and have the safety controller prevent the crashes. You should also be able to walk in front of the racecar without it running into you. At the same time your racecar should not be \"scared\". You should still be able to drive close to walls, turn around corners, go fast etc. without the racecar freezing in its tracks. You will be required to run your safety controller in all future labs so don't cripple yourself with something overprotective. Please be careful when you are testing . Always have your joystick ready to stop the racecar and start very slow.","title":"Part 3: Safety Controller"},{"location":"week1/01_monday/lab/#muxes","text":"The racecar has a command mux with different levels of priority that you will need in building your safety controller. The navigation topic you have been publishing to is an alias for the highest priority navigation topic in the mux ( defined here ): /vesc/ackermann_cmd_mux/input/navigation -> /vesc/high_level/ackermann_cmd_mux/input/nav_0 For brevity we will refer to /vesc/high_level/ackermann_cmd_mux/input/nav_i as .../nav_i in this handout ( this doesn't work on the actual racecar ). Driving commands sent to .../nav_0 override driving commands sent to .../nav_1 , .../nav_2 , etc. Likewise driving commands sent to .../nav_1 override driving commands sent to .../nav_2 , .../nav_3 , etc. You can use this structure to layer levels of control. For example, a robot whose job it is to explore randomly and collect minerals as it finds them could use 2 muxes. The controller that explores randomly could publish to a lower priority topic like .../nav_1 . Whenever the vision system detects minerals, it could begin to publish commands to a higher priority topic like .../nav_0 . .../nav_0 would override .../nav_1 until the minerals have been depleted and commands stopped being published to .../nav_0 . The navigation command with the highest priority is then published to /vesc/high_level/ackermann_cmd_mux/output . This topic is then piped to /vesc/low_level/ackermann_cmd_mux/input/navigation and fed into another mux with the following priorities (from highest to lowest): /vesc/low_level/ackermann_cmd_mux/input/teleop /vesc/low_level/ackermann_cmd_mux/input/safety /vesc/low_level/ackermann_cmd_mux/input/navigation .../teleop is the topic that the joystick publishes to. This will always have the highest priority. .../safety has the next highest priority. It will override anything published to .../navigation . This is where your safety controller will publish. So for your safety controller this means: Subscribe to /vesc/high_level/ackermann_cmd_mux/output to intercept the driving command that is being published. Subscribe to sensors like /scan . Publish to /vesc/low_level/ackermann_cmd_mux/input/safety if the command being published to the navigation topic is in danger of crashing the racecar.","title":"Muxes"},{"location":"week1/01_monday/lab2/","text":"Week 1 Monday Lab: Setting up and Driving Welcome to Racecar! First things first, we need to set up the cars to be able to control them. Goals Learn how to set up the car Be able to use ssh Practice controlling the car Implement basic autonomous driving programs Warning The Racecar is $4000 piece of equipment . Treat it with care! Setting up the car Set the car on a block on your table, such that the wheels aren't touching the table . Unless you're actually testing your code on the ground, leave the car on this block. Unplug the battery charger, and connect the battery to the board. On some cars, there will be two identical wires; you only need to plug one into the battery. On these, quickly press the battery's power button. If you hold it, it will change the settings. On other cars, there is a wire marked blue and a wire marked green, which you must plug into the corresponding ports). Turn on the car using the power button on the TX2 The lights should turn green. Plug in the motor battery Your car should look like this: SSHFS Mounting In order to access the files on the car, we're going to be using SSHFS to mount its files onto your computer, where you can edit them in VSCode. When you save these files locally, they will automatically get updated on the car! Follow these instructions to set it up: Ubuntu In terminal, type sudo apt-get install sshfs Create a local directory to store the car's files: sudo mkdir /path/yourDirectory . /path can be any folder on your computer where you want to mount the car. Then sudo sshfs -o allow_other,defer_permissions racecar@racecar:/home/racecar /path/yourDirectory . The password is racecar@mit. In order to make the mount permanent (so you don't have to do this every time you restart the car), we have to edit your /etc/fstab file. Type sudo vim /etc/fstab/ . If this file isn't empty, go to the bottom by pressing G$ . Press i , make a new line, and type in sshfs#racecar@racecar:/home/racecar /path/yourDirectory . Press esc then type :wq to quit. Mac OSX Download FUSE and SSHFS here Create a local directory to store the car's files: sudo mkdir /path/yourDirectory . /path can be any folder on your computer where you want to mount the car. Then sudo sshfs -o allow_other,defer_permissions racecar@racecar:/home/racecar /path/yourDirectory . The password is racecar@mit. In order to make the mount permanent (so you don't have to do this every time you restart the car), we have to edit your /etc/fstab file. Type sudo vim /etc/fstab/ . If this file isn't empty, go to the bottom by pressing G$ . Press i , make a new line, and type in sshfs#racecar@racecar:/home/racecar /path/yourDirectory . Press esc then type :wq to quit. Windows: Install win-sshfs SSH'ing Make sure your computer is connected to the car's wifi (it should appear as RACECAR_AP_yourCar'sNumber). In terminal, type ssh racecar@192.168.1.yourCar'sNumber . The password is racecar@mit. Make sure everyone on your team is able to do this before moving on! (You will have to ssh one at a time) Controlling the car Once you've successfully ssh'd in, type teleop . This will allow us to actually drive the car. If there is an error about it being unable to connect to the joystick, end the program (ctrl-C) and try again. If there is still an error, as a TA for help. Now you can drive the car using the controller! The cars have a Dead Man's Switch for safety; this means that to use the controller to drive, you have to hold down LB at the same time. If the Mode light is turned on, press Mode. The controller must also be in the D mode (this is changed by a switch in between the bumpers). Try driving around! The left joystick controls speed, and the right joystick turns. Keep in mind that these are expensive piece of equipment; always be aware of your/the car's surroudings when driving, and communicate with other teams that are also driving their cars to avoid damaging them. When you think you have a good feel of the car, move on to the next section. Intro to autonomous driving First, let's just program the racecar to drive forwards on its own. Open drive.py . We'll talk about this more tomorrow, but in order for different programs in the car to communicate with eachother, they use publishers and subscribers. After you change your driving variables, you must \"publish\" afterwards: self.pub.publish(self.cmd) . We've already set up the publishers and subscribers for today, but for the rest of the course you will have to write your own (don't worry, we'll explain it all tomorrow). For now, change the car's velocity in the function drive_callback . You can change the speed with the variable self.cmd.drive.speed . Start off with small values like 0.5 so you don't accidently crash! When you want to run your code on the car, press 'A' on the controller after teleop has been turned on. Next, try having the car drive in a circle. You can change the wheel angle with the variable self.cmd.drive.steering_angle (the car uses radians). Explore the range of values that might work best for your car (speed, turning angle, etc).","title":"Hardware"},{"location":"week1/01_monday/lab2/#week-1-monday-lab-setting-up-and-driving","text":"Welcome to Racecar! First things first, we need to set up the cars to be able to control them.","title":"Week 1 Monday Lab: Setting up and Driving"},{"location":"week1/01_monday/lab2/#goals","text":"Learn how to set up the car Be able to use ssh Practice controlling the car Implement basic autonomous driving programs","title":"Goals"},{"location":"week1/01_monday/lab2/#warning","text":"The Racecar is $4000 piece of equipment . Treat it with care!","title":"Warning"},{"location":"week1/01_monday/lab2/#setting-up-the-car","text":"Set the car on a block on your table, such that the wheels aren't touching the table . Unless you're actually testing your code on the ground, leave the car on this block. Unplug the battery charger, and connect the battery to the board. On some cars, there will be two identical wires; you only need to plug one into the battery. On these, quickly press the battery's power button. If you hold it, it will change the settings. On other cars, there is a wire marked blue and a wire marked green, which you must plug into the corresponding ports). Turn on the car using the power button on the TX2 The lights should turn green. Plug in the motor battery Your car should look like this:","title":"Setting up the car"},{"location":"week1/01_monday/lab2/#sshfs-mounting","text":"In order to access the files on the car, we're going to be using SSHFS to mount its files onto your computer, where you can edit them in VSCode. When you save these files locally, they will automatically get updated on the car! Follow these instructions to set it up:","title":"SSHFS Mounting"},{"location":"week1/01_monday/lab2/#ubuntu","text":"In terminal, type sudo apt-get install sshfs Create a local directory to store the car's files: sudo mkdir /path/yourDirectory . /path can be any folder on your computer where you want to mount the car. Then sudo sshfs -o allow_other,defer_permissions racecar@racecar:/home/racecar /path/yourDirectory . The password is racecar@mit. In order to make the mount permanent (so you don't have to do this every time you restart the car), we have to edit your /etc/fstab file. Type sudo vim /etc/fstab/ . If this file isn't empty, go to the bottom by pressing G$ . Press i , make a new line, and type in sshfs#racecar@racecar:/home/racecar /path/yourDirectory . Press esc then type :wq to quit.","title":"Ubuntu"},{"location":"week1/01_monday/lab2/#mac-osx","text":"Download FUSE and SSHFS here Create a local directory to store the car's files: sudo mkdir /path/yourDirectory . /path can be any folder on your computer where you want to mount the car. Then sudo sshfs -o allow_other,defer_permissions racecar@racecar:/home/racecar /path/yourDirectory . The password is racecar@mit. In order to make the mount permanent (so you don't have to do this every time you restart the car), we have to edit your /etc/fstab file. Type sudo vim /etc/fstab/ . If this file isn't empty, go to the bottom by pressing G$ . Press i , make a new line, and type in sshfs#racecar@racecar:/home/racecar /path/yourDirectory . Press esc then type :wq to quit.","title":"Mac OSX"},{"location":"week1/01_monday/lab2/#windows","text":"Install win-sshfs","title":"Windows:"},{"location":"week1/01_monday/lab2/#sshing","text":"Make sure your computer is connected to the car's wifi (it should appear as RACECAR_AP_yourCar'sNumber). In terminal, type ssh racecar@192.168.1.yourCar'sNumber . The password is racecar@mit. Make sure everyone on your team is able to do this before moving on! (You will have to ssh one at a time)","title":"SSH'ing"},{"location":"week1/01_monday/lab2/#controlling-the-car","text":"Once you've successfully ssh'd in, type teleop . This will allow us to actually drive the car. If there is an error about it being unable to connect to the joystick, end the program (ctrl-C) and try again. If there is still an error, as a TA for help. Now you can drive the car using the controller! The cars have a Dead Man's Switch for safety; this means that to use the controller to drive, you have to hold down LB at the same time. If the Mode light is turned on, press Mode. The controller must also be in the D mode (this is changed by a switch in between the bumpers). Try driving around! The left joystick controls speed, and the right joystick turns. Keep in mind that these are expensive piece of equipment; always be aware of your/the car's surroudings when driving, and communicate with other teams that are also driving their cars to avoid damaging them. When you think you have a good feel of the car, move on to the next section.","title":"Controlling the car"},{"location":"week1/01_monday/lab2/#intro-to-autonomous-driving","text":"First, let's just program the racecar to drive forwards on its own. Open drive.py . We'll talk about this more tomorrow, but in order for different programs in the car to communicate with eachother, they use publishers and subscribers. After you change your driving variables, you must \"publish\" afterwards: self.pub.publish(self.cmd) . We've already set up the publishers and subscribers for today, but for the rest of the course you will have to write your own (don't worry, we'll explain it all tomorrow). For now, change the car's velocity in the function drive_callback . You can change the speed with the variable self.cmd.drive.speed . Start off with small values like 0.5 so you don't accidently crash! When you want to run your code on the car, press 'A' on the controller after teleop has been turned on. Next, try having the car drive in a circle. You can change the wheel angle with the variable self.cmd.drive.steering_angle (the car uses radians). Explore the range of values that might work best for your car (speed, turning angle, etc).","title":"Intro to autonomous driving"},{"location":"week1/01_monday/setup/","text":"Overview We will be working with both the RACECAR hardware and simulator today. Although basic interactions with the hardware require only SSH , the full experience requires a local installation of Robot Operating System (ROS) on a GNU/Linux machine. (Note: Although ROS recently started supporting an official Windows 10 build , it is new and thus untested with our platform.) What is ROS? Despite its name, the Robot Operating System is not actually a bona fide OS. Rather it is a set of robotics middleware built on top of GNU/Linux. ROS is most commonly used in conjunction with Ubuntu , as ROS releases are tied to Ubuntu releases. For example: - Ubuntu 18.04, Bionic Beaver \u2192 ROS Melodic Morenia - Ubuntu 16.04, Xenial Xerus \u2192 ROS Kinetic Kame That being said, Debian is also well supported since Ubuntu is derived from it. If you have never used ROS before, it is best thought of as a standardized pub/sub messaging protocol with some handy libraries and visualization tools. Setup The next few sections will walk you through getting your personal machine setup with ROS as either a native install, Docker install, or Virtual Machine. * If you have a GNU/Linux machine (especially Ubuntu or Debian) and are comfortable on it, a native install will give you the best performance. * If you are on Windows, MacOS, or an unsupported flavor of GNU/Linux, BSD, etc., we encourage using our new Docker image. * If you have your own copy of VMWare installed, and prefer VMs to Docker (why would you though?), we can provide a Debian-based VM preloaded with all the software you'll need. If you already have ROS installed, you're good to go! Just make sure you have the following ROS packages installed: velodyne, ackermann-msgs, joy, and serial. Installation instructions for these packages are included at the end of the Native ROS Install section. Setup (Native ROS - Ubuntu/Debian) Step 1: Install ROS Based on your flavor of GNU/Linux, follow the linked installation instructions below. Be sure to install the ros-VERSION-desktop-full version of ROS. * Install ROS on Ubuntu 18.04 * Install ROS on Ubuntu 16.04 * Install ROS on Debian Stretch * Install ROS on Debian Jessie There is an experimental ROS installation for Arch Linux. While we love Arch, we've found the ROS package unreliable. If you must, you can follow the experimental instructions here . Step 2: Install Additional ROS Packages After ROS installation completes, install these additional ROS packages: # install on Ubuntu 18.04 & Debian Stretch sudo apt install ros-melodic-velodyne ros-melodic-ackermann-msgs ros-melodic-joy ros-melodic-serial # install on Ubuntu 16.04 & Debian Jessie sudo apt install ros-kinetic-velodyne ros-kinetic-ackermann-msgs ros-kinetic-joy ros-kinetic-serial Step 3: Install the racecar simulator code First make a racecar_ws : mkdir -p ~/racecar_ws/src Clone the racecar code: cd ~/racecar_ws/src git clone https://github.com/mit-racecar/racecar_simulator.git Make the code: cd ~/racecar_ws catkin_make source devel/setup.bash Setup (Docker) Step 1: Install Docker Community Edition (CE) Based on your OS, follow the linked installation instructions below. * Windows * Instructions * Installer * MacOS * Ubuntu * Debian * Fedora Step 2: Create a Mount Folder Create a folder to connect your Docker image to: # Windows mkdir C:\\Users\\YOUR_USER_NAME\\mount mkdir C:\\Users\\YOUR_USER_NAME\\mount\\jupyter_ws # MacOS mkdir -p ~/mount/jupyter_ws # GNU/Linux mkdir -p ~/mount/jupyter_ws Step 2: Run the Docker Image Start the docker image by running: # On Windows docker run -ti --net=host -v /C/Users/YOUR_USER_NAME/mount:/mnt/jupyter_ws fishberg/racecar # On MacOS sudo docker run -ti --net=host -v ~/mount:/mnt/jupyter_ws fishberg/racecar # On GNU/Linux sudo docker run -ti --net=host -v ~/mount:/mnt/jupyter_ws fishberg/racecar This will download the docker image the first time it is run and will cache it for future use. On some operating systems (OS X?) the --net=host flag does not properly forward ports. This can be fixed by manually specifying: sudo docker run -tip 6080:6080 -p 5900:5900 racecar/racecar For more instructions on using the docker image see here .","title":"Setup"},{"location":"week1/01_monday/setup/#overview","text":"We will be working with both the RACECAR hardware and simulator today. Although basic interactions with the hardware require only SSH , the full experience requires a local installation of Robot Operating System (ROS) on a GNU/Linux machine. (Note: Although ROS recently started supporting an official Windows 10 build , it is new and thus untested with our platform.)","title":"Overview"},{"location":"week1/01_monday/setup/#what-is-ros","text":"Despite its name, the Robot Operating System is not actually a bona fide OS. Rather it is a set of robotics middleware built on top of GNU/Linux. ROS is most commonly used in conjunction with Ubuntu , as ROS releases are tied to Ubuntu releases. For example: - Ubuntu 18.04, Bionic Beaver \u2192 ROS Melodic Morenia - Ubuntu 16.04, Xenial Xerus \u2192 ROS Kinetic Kame That being said, Debian is also well supported since Ubuntu is derived from it. If you have never used ROS before, it is best thought of as a standardized pub/sub messaging protocol with some handy libraries and visualization tools.","title":"What is ROS?"},{"location":"week1/01_monday/setup/#setup","text":"The next few sections will walk you through getting your personal machine setup with ROS as either a native install, Docker install, or Virtual Machine. * If you have a GNU/Linux machine (especially Ubuntu or Debian) and are comfortable on it, a native install will give you the best performance. * If you are on Windows, MacOS, or an unsupported flavor of GNU/Linux, BSD, etc., we encourage using our new Docker image. * If you have your own copy of VMWare installed, and prefer VMs to Docker (why would you though?), we can provide a Debian-based VM preloaded with all the software you'll need. If you already have ROS installed, you're good to go! Just make sure you have the following ROS packages installed: velodyne, ackermann-msgs, joy, and serial. Installation instructions for these packages are included at the end of the Native ROS Install section.","title":"Setup"},{"location":"week1/01_monday/setup/#setup-native-ros-ubuntudebian","text":"","title":"Setup (Native ROS - Ubuntu/Debian)"},{"location":"week1/01_monday/setup/#step-1-install-ros","text":"Based on your flavor of GNU/Linux, follow the linked installation instructions below. Be sure to install the ros-VERSION-desktop-full version of ROS. * Install ROS on Ubuntu 18.04 * Install ROS on Ubuntu 16.04 * Install ROS on Debian Stretch * Install ROS on Debian Jessie There is an experimental ROS installation for Arch Linux. While we love Arch, we've found the ROS package unreliable. If you must, you can follow the experimental instructions here .","title":"Step 1: Install ROS"},{"location":"week1/01_monday/setup/#step-2-install-additional-ros-packages","text":"After ROS installation completes, install these additional ROS packages: # install on Ubuntu 18.04 & Debian Stretch sudo apt install ros-melodic-velodyne ros-melodic-ackermann-msgs ros-melodic-joy ros-melodic-serial # install on Ubuntu 16.04 & Debian Jessie sudo apt install ros-kinetic-velodyne ros-kinetic-ackermann-msgs ros-kinetic-joy ros-kinetic-serial","title":"Step 2: Install Additional ROS Packages"},{"location":"week1/01_monday/setup/#step-3-install-the-racecar-simulator-code","text":"First make a racecar_ws : mkdir -p ~/racecar_ws/src Clone the racecar code: cd ~/racecar_ws/src git clone https://github.com/mit-racecar/racecar_simulator.git Make the code: cd ~/racecar_ws catkin_make source devel/setup.bash","title":"Step 3: Install the racecar simulator code"},{"location":"week1/01_monday/setup/#setup-docker","text":"","title":"Setup (Docker)"},{"location":"week1/01_monday/setup/#step-1-install-docker-community-edition-ce","text":"Based on your OS, follow the linked installation instructions below. * Windows * Instructions * Installer * MacOS * Ubuntu * Debian * Fedora","title":"Step 1: Install Docker Community Edition (CE)"},{"location":"week1/01_monday/setup/#step-2-create-a-mount-folder","text":"Create a folder to connect your Docker image to: # Windows mkdir C:\\Users\\YOUR_USER_NAME\\mount mkdir C:\\Users\\YOUR_USER_NAME\\mount\\jupyter_ws # MacOS mkdir -p ~/mount/jupyter_ws # GNU/Linux mkdir -p ~/mount/jupyter_ws","title":"Step 2: Create a Mount Folder"},{"location":"week1/01_monday/setup/#step-2-run-the-docker-image","text":"Start the docker image by running: # On Windows docker run -ti --net=host -v /C/Users/YOUR_USER_NAME/mount:/mnt/jupyter_ws fishberg/racecar # On MacOS sudo docker run -ti --net=host -v ~/mount:/mnt/jupyter_ws fishberg/racecar # On GNU/Linux sudo docker run -ti --net=host -v ~/mount:/mnt/jupyter_ws fishberg/racecar This will download the docker image the first time it is run and will cache it for future use. On some operating systems (OS X?) the --net=host flag does not properly forward ports. This can be fixed by manually specifying: sudo docker run -tip 6080:6080 -p 5900:5900 racecar/racecar For more instructions on using the docker image see here .","title":"Step 2: Run the Docker Image"},{"location":"week1/02_tuesday/lab/","text":"Coming soon!","title":"Tuesday"},{"location":"week1/02_tuesday/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week1/03_midweek/lab/","text":"Coming soon!","title":"Mid-Week Challenge"},{"location":"week1/03_midweek/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week1/04_eow/lab/","text":"Coming soon!","title":"End-of-Week Challenge"},{"location":"week1/04_eow/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week2/01_monday/lab/","text":"Coming soon!","title":"Monday"},{"location":"week2/01_monday/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week2/02_tuesday/lab/","text":"Coming soon!","title":"Tuesday"},{"location":"week2/02_tuesday/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week2/03_midweek/lab/","text":"Coming soon!","title":"Mid-Week Challenge"},{"location":"week2/03_midweek/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week2/04_eow/lab/","text":"Coming soon!","title":"End-of-Week Challenge"},{"location":"week2/04_eow/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week3/01_monday/lab/","text":"Coming soon!","title":"Monday"},{"location":"week3/01_monday/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week3/02_tuesday/lab/","text":"Coming soon!","title":"Tuesday"},{"location":"week3/02_tuesday/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week3/03_midweek/lab/","text":"Coming soon!","title":"Mid-Week Challenge"},{"location":"week3/03_midweek/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week3/04_eow/lab/","text":"Coming soon!","title":"End-of-Week Challenge"},{"location":"week3/04_eow/lab/#coming-soon","text":"","title":"Coming soon!"},{"location":"week4/coming-soon/","text":"Coming soon!","title":"Week 4"},{"location":"week4/coming-soon/#coming-soon","text":"","title":"Coming soon!"}]}